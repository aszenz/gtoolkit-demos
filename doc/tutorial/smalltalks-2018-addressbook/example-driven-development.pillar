! Example Driven Development Example Driven Development is a natural evolution of Test Driven Development (TDD). To explain it, let's start with an address book implementation using test cases. !! Test Driven Development Each contact is presented by three objects: ${class:DmAbContact}$, ${class:DmAbAddress}$, and ${class:DmAbTelephone}$. ${class:DmAbAddressBook}$ holds all contacts. The class definitions are the following: ${changes:01-domain.ombu}$ Let's write some test cases: ${changes:01-tests.ombu}$ Let's execute test cases:[[[show=gtMorphFor:|height=250(TestRunner new	packageSearchUpdate: 'AddressBook';	classSearchUpdate: 'DmAb';	selectAllPackages;	runAll;	build) height: 250]]]Let's make tests green implementing behavior: ${changes:02-domain-methods.ombu}$Let's execute test cases again: [[[show=gtMorphFor:|height=250(TestRunner new	packageSearchUpdate: 'AddressBook';	classSearchUpdate: 'DmAb';	selectAllPackages;	runAll;	build) height: 250]]]!!! Documentation and Learning Process When a product is ready to consume, we should also facilitate learning process. Do you agree? If so, what is the common process to support learning and reading? ... A documentation is a common entry point. Developers assemble software documentation commonly as an external documentation, blog posts, etc. There is an example of such documentation: ${inputFile:external-documentation.md}$.!!! TDD and Documentation IssuesWhat is the issue with the previous workflow? !!!! Non-Live DocumentationIt is not Live!!! Readers cannot really play with it unless they copy and paste all code. It can be improved using Pillar syntax that has support inside of Pharo: ${inputFile:external-documentation.pillar}$. By doing so, the reading experience is much better. Someone can read, execute, and modify code snippets.!!!! Obsolete and Non-Live DocumentationThere is still one issue with the improved Pillar documentation. As software products evolve, documentation tend to decay. Code snippets do not work anymore and there is no automated way to check documentation status as we do with test cases, e.g., Travis continuous integration.!!!! Double EffortWriting documentation is a double effort. All code snippets used in ${inputFile:external-documentation.pillar}$ were written once in test case methods already written once in test case methods. Check ${method:DmAbAddressBookTest>>#testMyContactsAddressBook}$!! Example Driven Development Let's see how Example Driven Development looks like. We start with a class definition, similar to ${class:DmAbAddressBookTest}$. The difference is that we do not subclass ${class:TestCase}$, but ${class:Object}$. Let's call it ${class:DmAbAddressBookExample}$.${changes:03-examples.ombu}$For more advanced assertions, developers can subclass ${class:GtExampleProvider}$.Let's create the first example: ${changes:04-first-example}$${example:DmAbAddressBookExample>>#addressTelephone}$ It is similar to ${method:DmAbAddressBookTest>>#testAddressTelephone}$Let's add two more examples: ${changes:05-example-methods}$${example:DmAbAddressBookExample>>#contactAddress}$${example:DmAbAddressBookExample>>#johnDoeContact}$Do you notice any issue in the previous example? Yes, there is one! We should have views that expose important object information. And we can do it so by adding an inspector extension: ${changes:06-contact-extensions}$${example:DmAbAddressBookExample>>#johnDoeContact}$We just observed that doing cheap inspector extensions is an important developer skill to make software more approchable. Inspector extensions are therefore an essential property of Example Driven Development.Let's exemplify and extend the rest of the address book: ${changes:07-more-examples}$${class:DmAbAddressBook}$ is already an interesting object where exposing information to a reachable form, make development experience different. See: ${example:DmAbAddressBookExample>>#myContactsAddressBook|previewExpanded|codeExpanded=false}$So, we have seen that combination of examples and inspector extensions make software approchable. How do we solve the documentation decay problem? We reuse the examples instead of writting code snippets as we did in the earlier documentation ${inputFile:external-documentation.pillar}$. Furthermore, we can write it as a class comment in ${class:DmAbAddressBook}$: ${changes:08-class-comment}$${examples:classes=#(DmAbAddressBookExample)}$You can read the class comment by navigating to ${class:DmAbAddressBook|show=gtDocumentFor:}$ and execute examples by going to ${class:DmAbAddressBookExample|show=gtExamplesFor:}$.!! Discussion and ConclusionExample Driven Development solve at least the four issues:# double effort of writing documentation # keeps documentation close to source code# documentation is live# source code and documentation are exemplified and therefore up-to-dateFor more examples see:- ${class:BlFrameLayoutSingleChildExamples|show=gtExamplesFor:}$, find ==Examples== tab- ${class:BrButtonLabelLookExamples}$- ${icebergFile:feenkcom/gtoolkit-visualizer/doc/mondrian/index.pillar}$