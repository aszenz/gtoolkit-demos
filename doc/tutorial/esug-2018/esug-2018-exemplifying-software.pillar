! Exemplifying softwareGT Examples is a slim engine that lets you define examples throughout the code and use them for documentation or testing. Through examples, a developer can switch rapidly from the static code to a live environment and program in the presence of objects. Examples then serve as the basis for live documentation.!!OutlookIn this tutorial we explore how to transform unit tests into example using the GT Examples framework for Pharo. We then look at what can be gained from this, especially when taking into account that in Pharo every object can have multiple custom views.For this demo, we write tests and examples for an application that detects faces within pictures using the Azure Face API.${example:name=GtCSGalleryExamples>>#galeryElementUnsplashOffline|previewExpanded=false|previewHeight=500|previewShow=gtLiveFor:}$Internally this application is structured using an object-oriented model containing two main entities, ==Picture== and ==Face==. A ==Picture== has a list of ==Face== objects, and a ==Face== object knows the ==Picture== it belongs to. Two other objects are used to store properties related to faces. Internally, a picture has a ==pictureForm== attribute that stores its graphical representation. Pictures can create this graphical representation by loading it from an URL.+file://design-overview.png+!!Creating unit tests for the Face API modelLet’s start with a few unit tests checking that our main domain objects are created and initialised correctly, written using the SUnit framework. For the very beginning, we start with a test covering the ${class:GtCSFace}$ object.${changes:01-testFaceInitialization-v1.ombu}$We can run this test, using the Test Runner, to ensure that is actually passes.[[[(TestRunner new	packageSearchUpdate: 'GToolkit-Demo-CognitiveServices';	classSearchUpdate: 'CSD';	selectAllPackages;	runAll;	build) height: 250]]]Next, let’s write a similar test for the initialisation of a ${class:GtCSPicture}$ object.${changes:02-testPictureInitialization.ombu}$Now that the basic initialisation of faces and pictures is covered, we can write several more tests that link them together.${changes:03-tests-faces-pictures.ombu}$Now we have a first test suite for our application consisting of 5 tests. We can use the Test Runner to check if these tests pass.[[[(TestRunner new	packageSearchUpdate: 'GToolkit-Demo-CognitiveServices';	classSearchUpdate: 'CSD';	selectAllPackages;	runAll;	build) height: 250]]]!! Creating GT Examples for the Face API modelNext, let’s write the same five tests as before, just instead of using SUnit, rely on the GT Examples framework. To show how a GT Example differs from a SUnit test, we take our initial unit test from the method ${method:GtCSDPictureTest>>#testFaceInitialization}$ and transform it into an example.${changes:04-example-faceEinstein-v1.ombu}$To make it an example, all we need to do is add the gtExample annotation to the method. This tells GT Examples that we want this method to be considered an example. Then, we can also return the Face object that we are creating. This is the example object that this example creates.${changes:04-example-faceEinstein-v2.ombu}$As in the case of SUnit, we can run this example to check if the assertions defined in the example pass. To run examples we can just inspect them. Any group of examples has a view that allows us to run those examples.[[[GtExplicitExampleGroup new examples: {(GtCSDPictureExamples >> #faceEinstein) gtExample}]]]We continue with an example for a picture with no face data and an URL.${changes:05-example-emptyPicture.ombu}$Next, let’s write an example for a picture that has face information, but no graphical representation. For this example we need a picture and several face objects. As we already have example methods for building faces and an empty picture, we can use them to get those objects.${changes:06-example-pictureWithFacesAndNoForm.ombu}$We still need to create two more examples. The first is an example of a picture that has a graphical representation. The second is an example of a picture with no face data and a graphical representation. ${changes:07-example-picturesWithForm.ombu}$At this point we have a set of seven examples. We can inspect them and check that the assertions they define are passing, like in the case of SUnit.[[[GtClassExampleGroup new exampleClass: GtCSDPictureExamples]]][[[(TestRunner new	packageSearchUpdate: 'GToolkit-Demo-CognitiveServices';	classSearchUpdate: 'CSD';	selectAllPackages;	runAll;	build) height: 250]]]!! Using examples to specify documentationBefore moving on to, let’s create a few more examples to capture other aspects of our model, like the landmarks that can be associated with ${class:GtCSFace}$ objects.${changes:08-example-picturesWithLandmarks.ombu}$With examples, we already have the code for creating interesting objects. Instead of copy-pasting that code into a document, we could directly embed the example in the document. Tools for working with that document can then embed the code, or any other information, directly in the document.GT Toolkit supports this kind of embedding using Pillar, a markdown-like markup language. For this example, we build a small document showing how to create Face objects with landmarks and how to add them to a Picture object that has a graphical representation. The next subsection contains that document.!!! Using Faces and Pictures objectsTo highlight faces within pictures we first need to create face objects. When creating a face we need to indicate the countour delimiting the face using the ==rectangle:== method.${example:name=GtCSPictureExamples>>#faceEinstein|expanded=false}$Landmarks are used to indicate the position of different elements on a face, like nose, eyes, mouth, etc. Initially a face has no landmarks. We can attach them to a ${class:GtCSFace}$ object using the method ==landmarks:==.${example:name=GtCSPictureExamples>>#faceEinsteinWithLandmarks|previewExpanded=false|previewShow=gtFaceLandmarksViewFor:|previewHeight=250}$In case the face object is already attached to a picture with a graphical representation, we can see the landmarks overlayed on the actual face.${example:name=GtCSPictureExamples>>#faceEinsteinWithLandmarksInPicture|previewExpanded=true|previewShow=gtFaceLandmarksViewFor:|previewHeight=250}$To create an empty picture we can directly instantiate the ==Picture== class. We can also specify a URL from where the graphical representation of the can be downloaded.${example:name=GtCSPictureExamples>>#emptyPicture}$To add faces to a picture we can use the ==addFace:== method. We can add faces before the face has a graphical representation.${example:name=GtCSPictureExamples>>#pictureWithFacesWithLandmarksAndNoForm|previewExpanded=true|previewShow=gtPictureFor:|previewHeight=250}$Finally, to see the position of faces we can all the ==ensurePictureForm== method. This method downloads the graphical representation from the URL atached to the picture.${example:name=GtCSPictureExamples>>#pictureWithFacesWithLandmarksAndForm|previewExpanded=true|previewShow=gtPictureFor:|previewHeight=250}$!! Wrapping upExamples are not there just to verify that code works as expected. They serve as a foundation for helping us build stories that better explain the intricate details of our systems and domains to both ourselves, other developers and business stakeholders alike. +file://test-examples-diff.png+But, taking full advantage of examples, does not mean changing our test methods to just return objects instead of throwing them away. It means changing the way we approach testing, and most important of all, changing our development tools to fully embrace examples, instead of stoping when assertions are green.+file://testrunner-exampleinspector.png+